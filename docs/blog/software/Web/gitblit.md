>intranet git

# 前端  
结构写 HTML 文件， 表现写 CSS 文件， 行为写 JavaScript 文件

UI交互的技术原理是面向对象的,但这个对象不是面向对象程序设计的那个对象（封装、继承、多态）。而是更高层次的一个概念（属性、事件、方法），把UI交互的图形的属性、事件、方法这三个要素封装成（图形）对象。

C/S编程，比如VB、WinForm、Java Swing、Android Framework、qt等等，UI交互图形封装成控件。这个设计，适合于外观是确定的，数据类型是确定的的场景。但是，在Web场景中，一千个人有一千个需求，内容是不断变更的，这样一来，C/S的图形控件就太重了，也就是代码逻辑耦合太高了，特别是网络通信、内容处理与表示等等混在一起。
作者：tom pareto
链接：https://www.zhihu.com/question/383581311/answer/1831890478
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

而Web三剑客（HTML、CSS、js）+HTTP正好能够适应Web这个场景。它采用了分离的理念，HTTP负责传输（HTTP位于底层，通过封装简化为与服务器交互的元素的GET、PUT、POST方法），HTML用来承载内容（HTML也有标签控制的，但是现在提倡尽量不在复杂场景下使用这些标签），CSS用来控制外观属性，js用来负责交互事件的响应。浏览器又作为它们的容器或载体，另有一番设计与理念。  
当然，一事利一事弊。由于把这些功能分离到不同的技术中，所以也就在概念上分割了，不是一个完整的概念，对于初学者很不友好，没有一个清晰的、明确的概念模型。这也是我对很多书籍最反感的地方，无前言无后语，无前因无后果。所以，CSS，它是一种控制交互图形元素的外观属性的技术。从人眼的视觉来理解的话，它是一个立体的蛋糕模型，也就是一层一层的蛋糕的框框，框框里面才是蛋糕的具体的内容，而不是平面的盒子模型，在这些框框上标明，这个里面是什么颜色、什么内容等等。另外，它为了把UI图形属性的模板适配到具体的图形元素，所以设计了几种适配技术和几种基本的固定格式，对于初学者来说，这种设计有“茴”字有几种写法的感觉，而且，CSS格式不自然、有点怪怪的感觉。

在前端的早期，由于UI交互的设计理论、计算机软件理论与实践还处于比较原始的阶段，所以，有用的就不错了，不能苛求。但是，随着技术的发展，我们可以看到，现在的React和Vue又要把属性、事件、方法给统一起来。

# wasm(WebAssembly)
>主要是为了满足以下几个关键需求：

性能提升：

JavaScript虽然是一门广泛应用于Web开发的脚本语言，但它在执行复杂计算、图形处理、加密算法等方面相对于原生代码存在性能差距。Wasm采用紧凑的二进制格式和针对底层硬件优化的指令集，允许代码接近原生速度执行，极大地提升了Web应用中的计算密集型任务的性能。

跨平台兼容性：

Wasm作为编译目标，允许开发者使用诸如C、C++、Rust等非JavaScript语言编写高性能代码，然后编译成Wasm格式，这些代码可以在任何支持Wasm的环境中执行，包括所有主流的Web浏览器以及部分非浏览器环境，实现了一种跨平台、跨架构的可移植性。

安全性增强：

Wasm的设计中包含了严格的沙箱模型，能够在保证性能的同时提供较好的安全边界，限制了潜在的安全风险。Wasm模块在执行时受到浏览器严格的安全策略控制，确保不会对宿主环境造成破坏。

可扩展性和互操作性：

Wasm与JavaScript可以无缝集成，开发者可以通过JavaScript API加载和操作Wasm模块，二者之间可以相互调用，这样既保留了JavaScript的灵活性，又借助Wasm获得了更强的计算能力。

资源优化：

Wasm模块经过压缩后的体积通常较小，加载速度快，有助于提高Web应用的启动和响应速度。
综上所述，WebAssembly是为了填补JavaScript在某些场景下的性能不足，同时提供一个安全、高效、可移植且与现有Web技术良好配合的解决方案，使得Web应用可以承载更加复杂的逻辑和功能。 

# blazor
>blazor最佳的使用场景其实类似Electron框架，打包成独立app，既解决了下载的问题，又能使用Web生态。可以嵌套在MAUI里面，实现跨平台的Blazor。其实就是Electron或者Uniapp那种套壳浏览器的C#版本。

*Blazor WebAssembly的优点*
- 在浏览器中执行C#代码，不需要额外的插件
- 可以基于WebAssembly的性能优势和可在浏览器内执行的能力，获得更快页面处理速度
- 支持无服务器和离线场景Blazor  
*WebAssembl的缺点*
- 需要加载太多资源，首次展现速度较慢
- 由于所有代码都在浏览器中执行，不能嵌入机密数据

*Blazor Server的优点*
- 页面加载是轻量级的服务器可以使用机密数据，例如访问数据库
- 支持100%的浏览器，即使是那些没有WASM支持的浏览器，如Internet Explorer
*Blazor Server的缺点*
- 需要ASP.NET Core服务器
- 不支持无服务器和离线场景
- 大量SignalR连接可能引发性能问题(SignalR 连接是 永久性 的。 SignalR 即使客户端进入空闲状态，连接仍保持打开状态。 在服务于多个客户端的高流量应用程序中，这些持久连接可能会导致服务器达到其最大连接数导致随机套接字错误和连接重置错误,还会占用一些额外的内存，用于跟踪每个连接)

作者：MyIO
链接：https://zhuanlan.zhihu.com/p/391305795
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 框架
1. 架构模式
古典框架：早期的Web框架（如Struts、ASP.NET Web Forms等）倾向于采用较为传统的MVC（Model-View-Controller）或者其他类似的分层架构。在这些框架中，视图和控制器紧密耦合，且常常需要手动管理状态和页面流转。

现代框架：现代Web框架如React、Vue.js、Angular、Django REST Framework、Express.js等更倾向于基于组件化和声明式编程的理念，或是RESTful API的设计思路。例如，在前端框架中，Vue和React强调组件化，利用虚拟DOM技术提升性能；而在后端框架中，更多关注API的设计和服务端渲染分离，利于前后端分离开发。

2. 异步和非阻塞IO
古典框架：早期框架可能没有内置对异步处理的良好支持，往往依赖同步I/O模型，导致性能瓶颈。

现代框架：现代框架普遍支持异步编程模型，利用事件循环、回调、Promise、async/await等机制，能够更好地处理高并发场景下的非阻塞I/O，提升性能。

3. 前后端分离
古典框架：古典Web开发经常是一体化的，前端和后端代码高度耦合，可能导致开发和维护复杂度增加。

现代框架：现代Web开发趋向于前后端分离，前端专注于UI和交互逻辑，通过API与后端进行数据交换，增强了可扩展性和复用性。

4. 数据绑定与更新
古典框架：数据绑定机制相对原始，可能需要手动维护DOM状态，更新视图的过程繁琐。

现代框架：现代前端框架提供了自动化的数据绑定和视图更新机制，如Vue的响应式系统、React的单向数据流和组件生命周期钩子等，简化了开发流程。

5. 工具链与生态
古典框架：早期生态相对有限，构建工具、测试工具和自动化流程不如现代框架成熟。

现代框架：伴随着npm、Webpack、Babel等工具链的成熟，现代Web框架拥有强大的生态系统，便于模块化开发、热更新、优化打包等高级功能。

6. 社区活跃度与技术演进
古典框架：许多古典框架因技术迭代速度慢，社区活力减弱，新的最佳实践和解决方案相对较少。

现代框架：现代框架因其创新性吸引了大量开发者参与，社区活跃，不断有新技术和最佳实践出现，保持框架与时俱进。



# Blazor
基于.net构建可交互的 web UI，在一个统一的环境中编写前后端代码，实现跨平台的 web 应用程序开发。

两种运行模型：

Blazor WebAssembly (WASM):

在这种模式下，Blazor 应用程序被编译成 WebAssembly，这是一种可在浏览器中运行的低级别字节码格式。这意味着应用可以直接在客户端浏览器上执行 C# 代码，而无需任何插件。
开发者可以利用 .NET Standard 库，编写高性能且安全的客户端 web 应用程序，同时享受到实时 UI 更新和原生性能体验。

Blazor Server:

在服务器模式下，Blazor 应用的 UI 渲染在服务器端完成，然后通过 SignalR 实现实时通信，将 UI 更新推送到客户端浏览器。
这种方式下，大部分应用逻辑在服务器端执行，减轻了客户端的计算压力，但需要持续的网络连接以保持状态同步。
Blazor 应用基于组件化开发模型，其中组件是具有独立 UI 和行为的小型、可复用的部分。组件使用 Razor 语法编写，结合 C# 和 HTML 创建动态、可交互的界面。


<h3><a id="Runner_27"></a>安装Runner</h3> 
<ul><li> <p>添加<code>Gitlab</code>官方源</p> <pre><code class="prism language-shell">$ <span class="token function">curl</span> -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">bash</span>
</code></pre> </li><li> <p>安装<code>Runner</code></p> <pre><code class="prism language-shell">$ <span class="token function">sudo</span> yum <span class="token function">install</span> -y gitlab-runner
</code></pre>
# 抱琴踏雪，人境俱清

负剑凌空
把酒临风，不知归途  